/**
 * Практическое занятие №1. Базовые типы данных, операторы языка, простой
 * ввод-вывод.
 *
 * В результате выполнения данной работы слушатель получает много мелких, но
 * необходимых для дальнейшей работы навыков, поэтому задание построено как
 * последовательность закомментированных блоков, которые требуется
 * последовательно раскомментировать, отвечая при этом на поставленные вопросы.
 *
 * Необходимое программное обеспечение:
 *
 * - Unix-совместимая командная строка (для Windows необходимо установить WSL);
 * - компилятор g++, отладчик gdb (для установки в командной строке: 
 *   `apt update; apt install gcc g++ gdb`)
 * - любимый текстовый редактор.
 *
 * Примерная последовательность действий при отладке проекта:
 * 1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст
 *    программы;
 * 2. скомпилируйте программу (в командной строке: `g++ -g lab1.cpp`);
 * 3. запустите отладчик (в командной строке `gdb ./a.out`);
 * 4. в отладчике установите точку останова на нужной строке (например, 
 *    `break 55` для 55 строки или `b 55` - так короче) и начните выполнение 
 *    программы (`run` или `r`).
 * 5. выведите значение интересующей переменной (`print cByte` или `p cByte`)
 *    или добавьте переменную для постоянного отслеживания (`watch cByte`).
 * 6. Переходите к следующей точке останова (`c`) или к следующей строке (`n`).
 */

#include  <iostream>



int nTwin = 1;
namespace TwinSpace { int nTwin = 2; }

char upper(char sym){
    if ((sym >= 'a') && (sym <= 'z')){ // если в диапозоне от a..z
        return sym - 0x20;
    }
    return sym;
}

char lower(char sym){
    if ((sym >= 'A') && (sym <= 'Z')){ // если в диапозоне от A..Z
        return sym + 0x20;
    }
    return sym;
}

char disRegister(char sym){
    if ((sym >= 'A') && (sym <= 'Z')){ // если в диапозоне от A..Z
        return lower(sym);
    }
    return upper(sym);
}

int main()
{

    /**
     * Задание 1. Работа с отладчиком. Базовые типы данных. Литералы.
     *
     * Выполняя программу по шагам, следите за значениями переменных и
     * интерпретируйте результат (помните, что количество байт, отводимых под
     * int, системо-зависимо).
     *
     * Обратите внимание на разную интерпретацию отладчиком signed и unsigned
     * целых типов данных, а также на внутреннее представление отрицательных
     * целых чисел.
     */
    
    char cByte = 'A'; // 65 'A'
    cByte = 0x42; // old 65 -> new 66 'B' 42(16)
    cByte = 66; // тк значение такое же, то отладчик не отобразил изминение
    cByte = -1; // old 66 -> new 255

    unsigned char ucByte = 0x41; // 65 'A'
    ucByte = 'B'; // new 66 'B'
    ucByte = -1; // new 255

    int iInt = 0xffffffff; // тк int, самый весомый бит отвечает за знак, остальные конвертируются - new -1

    unsigned int uiInt = 0xffffffff; // unsigned int считатет самый весомый бит за значения, по этому - new 16^8 - 1; 4294967295

    float fFloat = 1.f;  // old - trash new - 1
    double dDouble = 1.; // old - trash new - 1

    /**
     * Выполните фрагмент, приведенный далее. В комментариях отразите, что
     * реально заносится в переменную. Объясните разницу между этим значением и
     * инициализатором.
     */

    double d = 0.1234567890123456789123456789; // d - 0.12345678901234568 тк 8 байта
    float  f = 0.1234567890123456789123456789; // f - 0.123456791 тк 4 байта

    d = 1.; // d - 1
    d = 0.999999999999999999999999999999999; // d - 1 тк округление ведёт к 1

    /**
     * В комментариях напишите результат, возвращаемый оператором sizeof для
     * переменной типа wchar_t (ее размер)
     */

    wchar_t cw = L'Ф'; // хранит символы, которые не вмещаются в 1 байт в win - 2 байта в linux - 4 байта
    size_t n = sizeof(cw); // в данном примере определяется, что данная переменная занимает 4 байта в памяти

    /**
     * Задание 2a. Неявное приведение типов данных. 
     *
     * Объясните разницу результата при выполнении (1) и (2): Покажите явно
     * (напишите в коде) преобразования, которые неявно выполняет компилятор
     */

    iInt = 1;
    double dDouble1 = iInt / 3;     // итог - 0 тк оставляет целочисленную часть int / int - int
    double dDouble2 = iInt / 3.;    // итог - 0.33333333333333331 тк int / double или float - double или float

    /**
     * Ассоциативность операторов.
     *
     * Синтаксис языка C допускает "цепочечное" присваивание (как в строках (1)
     * и (2)). Посмотрев результаты выполнения строк (1) и (2) (значения
     * переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок
     * выполнения присваиваний при цепочечной записи и объясните результат.
     *
     * Расставьте скобки, явно определяющие порядок выполнения, как это сделал
     * бы компилятор. Объясните (в комментариях) предупреждения (warnings)
     * компилятора.
     */

    short sShort;
    dDouble = fFloat = iInt = sShort = cByte = 3.3 / 3; // приоритет присваивания с правого
    
    cByte = sShort = iInt = fFloat = dDouble = 3.3 / 3; // приоритет присваивания с правого

    /**
     * Ниже Вам дан пример "небрежного" использования неявного приведения
     * типов, что может привести к нежелательным результатам - объясните (в
     * комментариях), к каким?
     *
     * Напишите явно преобразования, которые неявно выполняет компилятор.
     */

    iInt = 257;
    cByte = iInt; // 257 -> 1_00000001 -> 00000001

    unsigned char cN1 = 255, cN2 = 2, cSum;
    cSum = cN1 + cN2; // 255 + 2 -> 1_00000001 -> 00000001

    /**
     * Сравните предыдущую строчку с приведенной ниже. 
     *
     * Объясните (в комментариях), почему в следующей строке не происходит
     * выход за разрядную сетку
     *
     * Напишите явно преобразования, которые неявно выполняет компилятор
     */

    int iSum = cN1 + cN2; // size int - 4 байта -> 11111111 + 00000010 -> (0)_(0)_00000001_00000001

    /**
     * Напишите, почему при сложении одинаковых значений (одинаковых в двоичной
     * системе) в строках (1) и (2) получаются разные результаты.
     *
     * Напишите явно преобразования, которые неявно выполняет компилятор и
     * объясните, что при этом происходит.
     */

    char c1 = 0xff, c2 = 2; // c1 -> ff(16) -> 11111111(2) -> 255(10) c2 -> 2(10) -> 10(2)
    unsigned char uc1 = 0xff, uc2 = 2; // uc1 -> ff(16) -> 11111111(2) -> 255(10) uc2 -> 2(10) -> 10(2)
    int iSum1 = c1 + c2;   // sum -> 257 тк unsigned на char по дефолту
    int iSum2 = uc1 + uc2; // sum -> 257 тк unsigned на char по дефолту

    
    /**
     * Задание 2b. Явное приведение типов данных.
     *
     * Проинтерпретируйте результат (значения переменной dDouble) в строке (3).
     *
     * Напишите явно преобразования, которые неявно выполняет компилятор.
     */

    int nTmp = 100, nn = 3;
    dDouble = 3.3 + nTmp / nn; // 100 / 3 -> 33; 3.3 + 33 -> 36,2(9)

    /**
     * Получите результат без потери точности с помощью оператора явного
     * приведения типа.
     */

    
    double dDouble3 = 3.3 + nTmp / double(nn);

    /**
     * Задание 3. Область действия, область видимости и время существования
     * переменных.
     *
     * В этом фрагменте фигурируют четыре переменных с одним и тем же именем
     * nTwin - одна глобальная, вторая определена в своем пространстве имен,
     * (определены выше в начале модуля) третья - локальная внутри функции
     * main(), четвертая - вложенная локальная внутри блока. 
     *
     * В данном задании требуется в выделенных местах фрагмента определить, к
     * какой из четырех переменных идет обращение, а также факт существования и
     * видимости для всех четырех, заполнив приведенные в задании таблицы.
     *
     * Для выведения информации в отладчике можно воспользоваться командой 
     * `info locals`, которая выведет локальные переменные в функции main(),
     * и командой `watch nTwin` или `wacth ::nTwin` для отслеживания значений
     * переменных.
     */

    nTwin = 100; // глобальная переменная, тк нет локальной, можно писать так
    TwinSpace::nTwin = 300; // переменная пространства имён TwinSpace
    nTwin++; // old -> 100 new -> 101

    int nTwin; // init local var
    nTwin = 200; // new -> 200
    ::nTwin++; // old -> 101 new -> 102 global
    {
        //int nTwin; // init  v_local var
        nTwin = -1; // new -> -1
        ::nTwin++; // old -> 102 new -> 103
        TwinSpace::nTwin++; // old -> 300 new 3001
    }

    nTwin--; // local old -> 200 new -> 199


    /**
     * Задание 4. Спецификатор класса памяти - static.
     *
     * 1. Для каждой итерации цикла напишите значения пременных nLocal# и
     *    nStatic#.
     * 2. Напишите, когда выполняется инициализация обеих переменных.
     * 3. Поясните (в комментарии) разницу между способом инициализации
     *    переменных nStatic1 и nStatic2 и поясните побочный эффект, влияющий 
     *    на переменную nLocal2.
     */

    /*
    1 итерация i -> 0:

    1   init nStatic1 
        new -> 100
    2   init nLocal1 
        new -> 100
    3   init nLocal2 
        new -> 200
    4   init nStatic2
        new -> 200 * 2 -> 400
        nLocal2 old -> 200 new -> 201
    5   nStatic1 old -> 100 new -> 101
    6   nStatic2 old -> 401 new -> 202
    7   nLocal1 old -> 

    2 итерация i -> 1:
        тоже самое
    3 итерация i -> 2:
        тоже самое
    */

    for 
    (
        int i = 0; // start
        i < 3; // True -> выполнять
        i++ // после итерации
    )
    {
        static int nStatic1 = 100; // в начале программы (но тк она сразу присваивается, то каждую итерацию)
        int nLocal1 = 100; // в каждой итерации
        int nLocal2 = 200; // в каждой итерации
        static int nStatic2 = nLocal2++ * 2; // 400
        nStatic1++; // 101
        nStatic2++; // 202
        nLocal1++; // 100
    }

    /**
     * Напишите:
     * 1. как изменилось поведение пременной nStatic1?
     * 2. как эта переменная _инициализирована_?
     */

    for 
    (
        int i = 0; // start
        i < 3; // True -> выполнить
        i++ // после итерации
    )
    {
        static int nStatic1; // обьявляется в начале програмсы
        nStatic1 = 100; // даётся значение
        int nLocal1 = 100; // каждую итерацию
        nStatic1++; // 101
        nLocal1++; // 101
    }

    /**
     * Задание 5. Перечисления - enum.
     *
     * Обратите внимание на явную и неявную инициализацию констант. 
     *
     * Выполняя задание по шагам, следите за значениями, которые принимает
     * переменная myColors.
     */

    enum eColors
    {
        BLACK,
        BLUE,
        GREEN,
        RED=5,
        YELLOW,
        WHITE=RED+4
    };
    
    eColors myColors; //объявление переменной типа eColors 
    myColors = BLACK; // BLACK
    myColors = BLUE; // BLUE
    myColors = GREEN; // GREEN
    myColors = RED; // RED
    myColors = YELLOW; // YELLOW
    myColors = WHITE; // WHITE

    int nnn = BLACK; //любой целочиxсленной переменной можно присвоить
                     //значение из списка инициализирующих значений 
    // value - 0

    nnn = BLUE; // 1
    nnn = YELLOW; // 6

    //Именованные константы можно использовать в выражениях:
    nnn = BLUE | YELLOW; // or в дискретной математике работает как сложение BLUE (1) + YELLOW (6) = 7

    /**
     * Раскомментируйте следующую строку и обратите внимание на ошибку при
     * компиляции.
     *
     * Модифицируйте выражение таким образом, чтобы компилятор не выдывал
     * ошибки.
     */

    myColors = eColors(1); // 1 - BLUE

    /**
     * Выполните следующее присваивание НЕ меняя перечисление и тип переменной
     * myColors.
     */

    myColors = eColors(123); // 123 - не вхоидит в enum, пишется просто как число


    /**
     * Задание 6.1 Логический тип bool.
     *
     * Выполняя задание по шагам, следите за значениями переменной b и
     * интерпретируйте результат. 
     *
     * Напишите эти значения в комментариях.
     */

    int nNumber = 1;
    bool b = (nNumber != 0); // true
    b = (nNumber == 0); // false
    b = (nNumber > 0); // true
    b = (nNumber > 1); // false
    b = 5; // true

    /**
     * Вы всегда можете преобразовать логическое значение к целому явно или
     * компилятор может это сделать самостоятельно (неявно).
     *
     * Обратите внимание: как интерпретирует значения логических переменных
     * компилятор?
     */

    int tmp =  b + 1; // 2

    /**
     * Задание 6.2.
     *
     * В Григорианском календаре (которым мы все пользуемся) високосный год
     * определяется по следующему алгоритму: високосным является каждый
     * четвертый год, но каждый сотый високосным не является, при этом каждый
     * 400-й год все таки високосный. Т.е. 1823 - не високосный, 1824 -
     * високосный, 1900 - не високосный, 2000 - високосный.
     *
     * Напишите фрагмент кода, такой что логическая переменная isLeapYear
     * принимает значение true, если год, заданный переменной year -
     * високосный. Проверьте значение в отладчике.
     *
     * Указание: в этом задании нельзя использовать операторы if-else, switch и
     * тернарный оператор; необходимо написать логическое выражение в одну
     * строку.
     */
    

    {
        int year = 1823;
        // TODO: review and check - сделал
        bool isLeapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
        // (если кратен 4 и не кратен 100) или (кратен 400)
        year = 1824;
        isLeapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);

        year = 1900;
        isLeapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);

        year = 2000;
        isLeapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
    }

    /**
     * Задание 7. Модификатор const и переменные.
     *
     * Раскомментируйте следующие две строчки и объясните (в комментариях)
     * ошибки при компиляции.
     */

    {
        // const int nN; // требуется сразу обозначение значения
        // nN = 1; // нельзя константу менять
    }

    /**
     * Задание 8. Потоки ввода и вывода C++.
     *
     * Напишите фрагмент кода, который бы с помощью объектов потока std::cin и
     * std::cout делал бы следующее:
     *
     * 1. Выводил бы на экран номер задания.
     * 2. Считывал целое число.
     * 3. Считывал символ.
     * 4. Выводил пользователю введенный им символ.
     * 5. Выводил пользователю введенное им целое число.
     *
     * При этом добавьте в места, где от пользователя ожидается ввод,
     * соответствующие приглашения ко вводу (например, `Введите целое число: `). 
     */

    {
        int inputInt;
        char inputChar;

        std::cout << "Задание 8. Потоки ввода и вывода C++." << std::endl << "Введите целое число: ";
        std::cin >> inputInt;
        std::cout << "Введите символ: ";
        std::cin >> inputChar;
        std::cout << inputChar << std::endl;
        std::cout << inputInt << std::endl;
    }

    /**
     * Задание 9. Логические условные операторы и операторы отношения.
     */

    /**
     * Задание 9.1. 
     *
     * Напишите фрагмент кода, который переводит код символа, хранящийся в
     * переменной ch в противоположный регистр.
     *
     * Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
     * или нажал другую клавишу, которой символ не соответствует.
     *
     * Подсказка: работаем только с символами английского алфавита, для
     * которого в таблице кодов ASCII код каждой буквы нижнего регистра на 0x20
     * больше кода соответствующей буквы верхнего регистра.
     */
    char sym = 'A';
    {

        // TODO: проверить как работает - сделал
        std::cout << "Задание 9.1. Перевод в обратный регистр" << std::endl << "Введите символ: ";
        
        char ch;
        /** Тут сформируйте значение переменной ch с помощью потока ввода. */
        std::cin >> ch;
        /** Тут измените регистр. */
        // в начале кода алгоритм
        /** Тут вывели получившийся символ пользователю. */
        std::cout << disRegister(ch) << std::endl;
    }

    /**
     * Задание 9.2. 
     *
     * Напишите фрагмент кода, который реализует с помощью if (if/else)
     * следующую логику: если x меньше или равен 0, y=0, если x больше 0 но
     * меньше 1, то y=x, если x больше или равен 1, то y=1.
     *
     * Подумайте: какого типа должны или могут быть x и y?
     */

    {
        double x, y;
        std::cout << "Задание 9.2. " << std::endl << "Введите число x: ";
        std::cin >> x;
        if (x <= 0){
            y = 0;
        }
        else{
            // TODO: проверить, какой приоритет у операций - сначала приоритет &, после < и >
            if ((x > 0) && (x < 1)){
                y = x;
            }
            else{
                y = 1;
            }
        }
        std::cout << "(" << x << ", " << y << ")" << std::endl;
    }

    /**
     * Задание 9.3 
     *
     * Напишите фрагмент кода, который реализует с помощью switch следующую
     * логику: в переменной cInput типа char дано значение символа, введенного
     * любым способом.
     *
     * Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
     * переменной у значение переменной x.
     *
     * Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
     * переменной у значение (x * 2).
     *
     * Если любой другой симол, то вывести сообщение об ошибке.
     */

    {
        char cInput;
        int x, y;
        x = 10;
        std::cout << "Задание 9.3 " << std::endl << "Введите cимвол cInput: ";
        std::cin >> cInput;
        cInput = lower(cInput);  // TODO: fixme - сделал
        switch (cInput)
        {
        case 'y':
            y = x;
            break;
        
        case 'n':
            y = x * 2;
            break;
        
        default:
            std::cout << "Ошибка введённого символа" << std::endl;
        }
    }

    /**
     * Задание 10. Циклы.
     */

    /**
     * Задание 10.1.
     *
     * Напишите фрагмент кода, который реализует с помощью for следующую
     * логику: найти сумму заданного диапазона целых чисел.
     *
     * Введите границы с помощью потока ввода или с помощью средств отладки. 
     *
     * Предусмотрите защиту от ввода нижней границы больше, чем верхней.
     */

    {
        

        /** сформироыать границы диапазона */
        int dS, dF;
        std::cout << "Задание 10.1. " << std::endl << "Введите начало диапозона: ";
        std::cin >> dS;
        std::cout << "Введите конец диапозона: ";
        std::cin >> dF;

        /** проверить корректность значений */
        if (dS > dF){
            return 1;
        }
        /** вычислить сумму */
        int n = 0;
        for (int i = dS; i <= dF; i++){
            n += i;
        }
        /** проверить в отладчике значение */
        std::cout << n << std::endl;
    }

    /**
     * Задание 10.2. 
     *
     * Напишите фрагмент кода, который реализует с помощью do-while следующую
     * логику: на каждой итерации цикла ввести с консоли целое значение и
     * покинуть цикл, если значение удовлетворяет условию: значение больше или
     * равно 10 и четное.
     */

    {
        int iN;
        do{
            std::cout << "Задание 10.2. " << std::endl << "Введите число: ";
            std::cin >> iN;
        }
        while (
            !(
                (iN >= 10) && 
                (iN % 2 == 0)
            )
        ); // TODO: fixme - сделал

        // отрицание ( (больше или равно 10) и (кратен 2) )

        // отрицание условия выхода
    }

    /**
     * Задание 10.3. 
     *
     * Напишите фрагмент кода, который реализует с помощью while следующую логику: 
     *
     * 1. исходно int x = 0; 
     * 2. на каждой итерации x = x + 1, sum = sum + 1 / x;
     * 3. необходимо найти значение x, при котором sum > 1.7.
     */

    {
        std::cout << "Задание 10.3. " << std::endl;
        // TODO: почему x задан как float? - сделал
        int x = 0; // поменял на int
        float sum = 0;
        while (sum <= 1.7)
        {
            x += 1;
            sum = sum + 1. / x; // тк x int, чтобы считалось в float, нужно записать 1.
        }
        std::cout << x << std::endl;
    }

    /**
     * Задание 10.4. 
     *
     * Раскомментируйте следующий блок кода, который считает сумму 10
     * последовательных натуральных чисел, начиная со 120. 
     *
     * Объясните логические ошибки в нем и исправьте их.
     */

    {
        std::cout << "Задание 10.4. " << std::endl;
        // char start = 120, sum = 0;
        int start = 120, sum = 0;
        // for (char n = start; n < start + 10; ++n) {
        for (int i = start; i < start + 10; i++){
        //    sum += n;
            sum += i;
        // }
        }
        std::cout << sum << std::endl;
    }

    return 0; /** код завершения приложения */
}
