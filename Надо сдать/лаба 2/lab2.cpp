/**
 * Практическое занятие №2. Побитовые операторы. Директивы препроцессора.
 * Указатели.
 */

#include <iostream>
#include <cmath>

#if defined DEBUG
    #include <1.h>
#elif defined RELEASE
    #include <2.h>
#endif

// маска и сдвиг
int get_bit(int num, int index)
{
    return (num & (1 << index)) >> index;
}

// вывод числа в бинарном виде (со нулями и без)
void view_bin(int num, bool is_all)
{    
    int var_size = sizeof(num) * 8;
    int i = var_size - 1;
    while ((get_bit(num, i--) == 0) && (is_all));
    for (; i >= 0; i--) std::cout << get_bit(num, i);
    std::cout << std::endl;
}

int main()
{
    #ifdef NDEBUG
    printf("Тестовая сборка для отладки\n");
    printf("Файл сборки %s\n", __FILE__);
    printf("Время и дата сборки %s %s\n", __TIME__, __DATE__);
    printf("Функция и строка %s %i\n", __func__, __LINE__);
    #endif

    /**
     * Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
     */

    /**
     * Задание 1.1.
     * 
     * Задайте значение переменной `y`, например, с помощью потока ввода.
     *
     * 1. С помощью побитовых операторов и операторов сдвига выведите значение
     *    переменной `y` на консоль в двоичном виде.
     * 2. Сделайте то же, но пропустив незначащие нули.
     *
     * Например, если `y == 9`, то должно получиться
     * 1. `0 0 0 0 ... 0 0 1 0 0 1` (количество двоичных цифр зависит от
     *    платформы).
     * 2. `1 0 0 1`.
     *
     * Что выведет ваша программа, если ввести отрицательное число? Объясните
     * этот результат.
     */

    {
        std::cout << "1.1" << std::endl;
        int y;
        std::cin >> y;
        view_bin(y, true);
        view_bin(y, false);
        // работает
    }

    /**
     * Задание 1.2.
     *
     * Дана целая переменная `y`, задайте ее значение, например, с помощью
     * потока ввода.
     *
     * В рамках одного цикла "сдвиньте" все единицы в переменной `y` вправо,
     * обновив тем самым значение этой переменной.
     *
     * Например:
     * было:  0100 1111 0000 0000 0110 1111 0000 0010
     * стало: 0000 0000 0000 0000 0000 1111 1111 1111
     *
     * Выведите переменную на экран в двоичном виде до преобразования и после,
     * используя код из задания 1.1.
     */

    {
        std::cout << "1.2" << std::endl;
        int y;
        std::cin >> y;
        int count = 0;
        int var_size = sizeof(y) * 8;
        view_bin(y, false);
        for (int i = 0; i < 32; i++){
            count += get_bit(y, i);
        }
        y = int(pow(2, count)) - 1;
        view_bin(y, false);
        // работает
    }

    /**
     * Задание 1.3.
     *
     * Дана целая переменная `y`, задайте ее значение.
     *
     * Напишите код, который с помощью побитовых операций:
     *
     * 1. вычислит `y * 2^n`, где целое `n` (0 <= n < 16) задается отдельно;
     * 2. проверит, делится ли `y` на 2, проверит, делится ли `y` на 4;
     * 3. вычислит целую часть логорифма `y` по основанию 2.
     */

    {
        int y, n;
        bool flag1, flag2;

        std::cout << "1.3" << std::endl;
        std::cin >> y;
        std::cin >> n;
        // 1. сдвиг на значение степени эквиваелентно умножению на основание в степени
        std::cout << (y << n) << std::endl;
        // 2. проверка деление способом проверки битов
        flag1 = (get_bit(y, 0) == 0); // проверка меньшего бита
        flag2 = (get_bit(y, 1) == 0) && flag1; // меньший бит и следущий
        std::cout << flag1 << " " << flag2 << std::endl;
        // 3. нахождения логорифма с помощью самого большего бита 1
        int count = 0;
        int var_size = sizeof(y) * 8;
        int i = var_size - 1;
        while (get_bit(y, i) == 0)
        {
            i--;
        }
        std::cout << i << std::endl;
        //работает
    }

    /**
     * Задание 1.4.
     *
     * Какие операции следует применить к заданному ниже операнду sNum для
     * того, чтобы переменная sRes приняла требуемое значение? Каждую побитовую
     * операцию можно использовать только 1 раз.
     *
     * Замечание: значения подобраны таким образом, что в каждом случае
     * достаточно использовать один оператор (и при необходимости маску). 
     */

    {
        short sNum = 0x8008;
        short sRes;

        /** sRes == 0x7ff7 */
        sRes = ~sNum; // отрицание
    
        /** sRes == 0x8ff8 */
        sRes = sNum + 0x0ff0; // сложение


        /** sRes == 0x0008 */
        sRes = sNum - 0x8000; // разность

        /** sRes == 0x7f08 */
        sRes = sNum^0xff00; // XOR

        /** sRes == 0xf001 */
        sRes = sNum >> 3; // сдвиг вправа

        /** sRes == 0x0010 */
        sRes = sNum << 1; // сдвиг влево
        // работает
    }
    
    /**
     * Задание 2. Директивы препроцессора.
     */

    /**
     * Задание 2.1. Использование "математических" макросов стандартной
     * библиотеки.
     *
     * В заголовочном файле <cmath> (который в свою очередь включает старый
     * файл math.h) определены часто используемые математические константы,
     * например M_PI. Воспользуйтесь этой константой для вычисления длины
     * окружности.
     */

    {
        float radius = 2;
        float circumference = 2 * M_PI;
        //std::cout << "Задание 2.1\n" << circumference << "\n";
        // работает
    }
    
    /**
     * Задание 2.2. Макросы с параметрами.
     */

    /**
     * Задание 2.2.1.
     *
     * Напишите свою макроподстановку LENGHT которая вычисляет длину
     * окружности. 
     */

    {
        #define LENGHT(a) a * M_PI
        /** Протестируйте написанный макрос для следующих ситуаций */

        float l1 = LENGHT(1 + 2); // 1 + (2 * M_PI) -> 7.28319
        float l2 = 1 / LENGHT(2); // 1 / 2 * M_PI -> 0 тк 1 - int
        
        #define LENGHT_NEW(a) (2 * double(a) * M_PI)

        float tl1 = LENGHT_NEW(1 + 2);
        float tl2 = 1 / LENGHT_NEW(2);

        //std::cout << "Задание 2.2.1\n" << tl1 << " " << tl2 << "\n";
        // работает
    }

    /**
     * Задание 2.2.2.
     * 
     * Определите макрос MAX(A, B) для вычисления б'ольшего значения из двух.
     */

    {
        /**
         * Используйте макрос следующим образом. Следите за изменением значений
         * переменных k, i, j. Объясните результат.
         *
         * Постарайтесь убрать побочные эффекты.
         *
         * Отметьте случаи, когда избежать побочных эффектов невозможно.
         */
        #define MAX(a, b) a >= b ? a : b
        int i = 10, j = 12, k;
        k = MAX(i, j); // k = 12
        //std::cout << k << std::endl;
        k = MAX(j, i) * 2; // k = 12, он просто подставляет
        // k = (MAX(j, i)) * 2; -> 24
        //std::cout << k << std::endl;
        k = MAX(j, i+3); // k = 13, в условии будет уже сложение
        //std::cout << k << std::endl;
        k = MAX(i--, j++); // j++ первее k = 13
        // сначала сравнит 10 и 12, но потом вернёт 13, тк postfix ++
        //std::cout << k << std::endl;

        #define MAX_NEW(a, b) (a >= b ? a : b)
        // такой макрос гарантирует, что сначала выполнятся операции в скобках
        // работает
    }

    /**
     * Задание 2.2.3. 
     *
     * Определите макрос EXCHANGE(X, Y)  для перестановки двух объектов типа
     * int в памяти местами. 
     *
     * Проверьте для приведенного фрагмента. 
     *
     * Подумайте, что будет делать макроподстановка, если переставляемые
     * значения разного типа??? - ошибка, тк память определенна для типо одного, но в неё вписывают другой тип
     */

    {
        #define EXCHANGE(X, Y) ({ int tmp = Y; X = Y; Y = tmp; })

        int x1=1, y1=-1;
        EXCHANGE(x1,y1);

        int x2=100, y2=-100;
        EXCHANGE(x2,y2);
        // работает
    }

    /**
     * Задание 2.3. Директивы условной трансляции.
     *
     * Выполняя следующий фрагмент, посмотрите, какое значение принимает
     * переменная iNN. 
     *
     * Что нужно сделать для того, чтобы результат был равен 0? 1? 2?
     */

    {
        int iNN;
#if defined NNN && defined MMM // если NNN и MMM обьявленно
        iNN = 0;
#elif defined MMM // если MMM обьявленно без NNN
        iNN = 1;
#elif defined NNN // если NNN обьявленно без MMM
        iNN = 2;
#else // если NNN и MMM не обьявленно
        iNN = -1;
#endif
    }
    // работает

    /**
     * Задание 2.4. Задание директив при сборке.
     *
     * При сборке программы компилятором можно установить необходимые
     * макроподстановки с помощью ключа `-D`. Например, чтобы при сборке 
     * была определена директива `A` без значения и директива `B` со значением
     * `1`, надо добавить следующие ключи к команде сборки: `-D A -D B=1`.
     * Таким образом команда сборки будет выглядеть примерно так:
     *
     * `gcc -g -D A -D B=1 lab2.cpp`
     *
     * Уберите из кода определения макросов NNN и MMM из прошлого задания и
     * приведите команды компиляции, которые заставят переменную iNN принять
     * нужное значение. 
     *
     * Проверьте их работоспособность.
     * 
     * Проверил
     */

    /**
     * Задание 2.5. Сборки "DEBUG" и "RELEASE". Предопределенные макросы
     * компилятора.
     *
     * При отладке удобно выводить дополнительную информацию, которая может
     * мешать в итоговой (релизной) версии программы.
     *
     * Существует стандартный макрос, который принято устанавливать при
     * релизной сборке - `NDEBUG`.
     *
     * TODO: С помощью макроса NDEBUG и предопределенных макросов выведите на консоль
     * для отладочной версии информацию о том, что это отладочная сборка, о
     * дате сборки, о имени файла, имени функции и строки. Для релизной сборки
     * такая информация не должна выводиться. - Сделал
     *
     * Для защиты работы соберите две версии программы: отладочную и итоговую.
     * Чтобы собрать итоговую версию в другом исполняемом файле, используйте 
     * ключ компилятора `-o`, примерно так: 
     *
     * `gcc <ваши опции> -o release.out lab2.cpp`
     */

    /**
     * Задание 3.Заголовочные файлы. Директива #include.
     */

    /**
     * Задания 3.1. 
     *
     * Создайте и подключите к проекту два заголовочных файла 1.h и 2.h.
     * 
     * В каждом заголовочном файле объявите перечисление с одинаковыми именами
     * констант, но сопоставьте именованным константам разные значения,
     * например:
     *
     * - 1.h - enum MyEnum{My1, My2, My3};  
     * - 2.h - enum MyEnum{My1=5, My2, My3};
     *
     * С помощью директив условной трансляции в DEBUG-версии пользуйтесь
     * значениями констант из 1.h, а в RELEASE-версии значениями констант из
     * 2.h.
     *
     * Замечание: заголовочные файлы принято подключать в верхней части файла,
     * до любых функций (хотя правила компиляции не запрещают подключить их
     * тут).
     */

    // написал в начале

    /**
     * Задание 4. Указатели. 
     */

    /**
     * Задание 4.1. 
     * 
     * Объявите объекты разных типов и проинициализируйте их.
     *
     * Объявите указатели соответствующих типов и проинициализируйте их
     * адресами заданных объектов. 
     *
     * Выполняя задание, с помощью отладчика посмотрите, какие значения будут
     * присвоены переменным-указателям и на что эти указатели "указывают".
     */

    {
        int iNum = 1; 
        int* pointerINum = &iNum; // выводит адрес памяти с данными iNum
        // если в дебаге прописать p *(значение с указателя) - выдаст значение переменной iNum

        char cSym = 1;
        char* pointerCSym = &cSym;

        float fNum = 1;
        float* pointerFNum = &fNum;
        // работает
    }

    /**
     * Задание 4.2.
     *
     * Объявите указатель на тип char и проинициализируйте его адресом
     * строкового литерала. Присвойте переменной типа char значение любого
     * элемента строки.
     *
     * Проверьте - возможно ли присвоить какое-либо значение по адресу,
     * задаваемому указателем?
     */

    {
        // TODO: <type> pc = "abc";
        //char cSym = 'A';
        const char *ptr = "abc";
        char cSym = "ABS"[0];
        char* pcSym = &cSym;
        *(pcSym) = "TEST"[2]; // cSym = 'S'
        // работает
    }

    /**
     * Задание 5. Арифметика указателей. Операция разыменования указателя.
     *
     * Выполните следующий код по строчкам в отладчике, проследите за
     * изменением значений указателей и значений объектов, на которые они
     * указывают. 
     *
     * Интерпретируте наблюдаемые результаты.
     */
    {
        // TODO: какой объем памяти адресуется указателем? - байт
        int nAr[3] = {1,3}; // массив на 3 ячейки, в котором уже есть 2 числа +
        int* pn = &nAr[0]; // указатель на начальный элемент массива +
        (*pn)++; // +1 к первому элементу +
        pn++; // +1 к адресу памяти (смещение на второй элемент массива) +

        char cAr[] = {'A', 'B', 'C', 'D'}; // создание массива с 4 элементами +
        char *pc = &cAr[0]; // указатель на начальный элемент +
        (*pc) = (*pc) + 5; // A + 5 -> F +
        pc = pc + 3; // указатель смещается на 3 элемента <=> i = 0 -> i = 3 +
    
        double dAr[3]={1.0,2.0}; // массив на 3 ячейки, в котором уже есть 2 числа +
        double *pd1 = &dAr[0]; // указатель на начальный элемент +
        double *pd2 = pd1; // указатель на память указателя +
        (*pd2) += 2; // +2 к dAr[0] +
        pd2 += 2; // +2 к памяти pd2 <=> i = 0 -> i = 2 +

        /** Объясните результат выполнения операции вычитания двух указателей */
        pd1 = &dAr[0]; 
        pd2 = &dAr[1];
        int nNumber = pd2 - pd1;
        // указатели смещаются в памяти на размер одного элемента
        std::cout << nNumber << std::endl;
        /** 
         * Сравните указатели pd2 и pd1 и с помощью cout выведите результаты
         * сравнения.
         */
        // работает
    }
/*
    /**
     * Задание 6. Явное преобразование указателя. 
     *
     * Иногда возникает необходимость одни и те же данные интерпретировать
     * по-разному, например, целое можно представить как совокупность четырех
     * байтов и работать с каждым байтом по отдельности. Для этого нужно иметь
     * возможность "указывать" как на целое, так и на байт. 
     * 
     * Следовательно, возникает необходимость явного преобразования указателя. 
     * 
     * Подсказка: для правильной интерпретации этого задания воспользуйтесь
     * возможностями отладчика представлять данные в интересующем Вас виде (в
     * данном случае - в шестнадцатеричном) - для этого можно использовать
     * команду print (p) с указанием шестнадцетиричного формата: `p/x`.
     */

    {
        unsigned int nObject = 0x55667788; // заполнение определённой памяти значением +
        unsigned int* pnObject = &nObject; // указатель на эту память +
        unsigned char* pucObject; // будущий указатель на ячейки массива +
        char cc; // +

        /**
         * Раскомментировав следующую строчку кода, обратите внимание на
         * сообщение компилятора - он не считает преобразование "легальным"
         * (безопасным)
         */
        // pucObject = static_cast<unsigned char*>(pnObject); // этот метод позволяет на произвожные классы менять указатель

        /**
         * А такое преобразование - целиком на совести программиста. Его можно
         * применять, только четко представляя себе результат преобразования.
         */
        pucObject = reinterpret_cast<unsigned char*>(pnObject); // разделение области на куски заданные размером unsigned char +

        /** Проследите за значениями переменной `cc`. Объясните результаты. */
        cc = pucObject[0]; // 0x88 + // TODO: перепроверить результы (чтобы вывести в 16-ричном виде (gdb) p/x cc) - сделал
        cc = pucObject[1]; // 0x77 +
        cc = pucObject[2]; // 0x66 +
        cc = pucObject[3]; // 0x55 +

        /**
         * Выполните следующие строки, наблюдая за значениями следующих
         * выражений: `cc`, `p` и `*p`.
         *
         * Зафиксируйте и интерпретируйте результаты.
         */
        cc = *(pucObject++); 
        // p += 1 , 0 -> 1 +
        // cc = p[0] +
        cc = (*pucObject)++;
        // cc = p[1] +
        // p += 1 +
        cc = ++*(pucObject);
        // *p += 1 +
        // cc = *p +
        cc = *(++pucObject);
        // p += 1 +
        // cc = *p +
        // работает
    }

    /**
     * Задание 7. Void-указатель. 
     */

    /**
     * Задание 7.1.
     * 
     * Выполняя задание, посмотрите - какие значения присваиваются
     * void-указателю.
     *
     * Обратите внимание: средствами отладчика вы не можете посмотреть
     * значения, на которые "указывает" void-указатель.
     */
    {
        void *pVoid; // создание воид указателя
        int nObject3 = 5;
        char cObject3 = 'A';
        int *pInt = &nObject3;  
        pVoid = &nObject3;
        pVoid = &cObject3;
        pVoid = pInt;

        /** 
         * Прежде, чем раскомментировать следующую строчку, вспомните: что
         * нужно сделать, чтобы выражение стало корректным?
         */
        pInt = static_cast<int*>(pVoid);
        // pInt=pVoid;
        // работает
    }
    
    /**
     * Что нужно сделать для того, чтобы следующее закомментированное выражение
     * стало корректным?
     *
     * В закоментированной строке необходимо объявить void-указатель.
     */
    {
        const int n = 1;
        void const* pInt = &n; // указательн на константу
        // работает
    }

    /**
     * Задание 7.2.
     *
     * При выполнении следующего фрагмента посмотрите, какие неприятности могут
     * Вас ожидать при явном приведении типа void-указателя, который в момент
     * времени (1) указывает на double, к типу указателя на int (2).
     */

    {
        double dObject3 = 33.33;
        // ... pVoid = &dObject3;  //(1) тут указывает на тип 64 бит
        
        // int nTmp = *(static_cast<int*>(pVoid)); //(2)  тут же указывает на 32 бита

        //void * pV = &dObject3;
        //std::cout << *(static_cast<int*>(pV)) << "\n";

        // итог: в таком случае первые 4 байта будут читаться памятью, 
        // как обычный int, что повлечёт к неправильному преобразованию числа

        // проверил (работает)
    }

    /**
     * Задание 8. Модификатор const. 
     */

    /**
     * Задание 8.1.
     *
     * В каждом из заданий объявите указатель требуемого вида. 
     *
     * Посредством каждого указателя попробуйте: 
     *
     * - получить значение по адресу;
     * - записать новое значение по адресу;
     * - модифицировать указатель.
     */

    /**
     * Задание 8.1.1. Указатель является константой. 
     */

    {
        // указатель на константу const <type> *
        // константный указатель <type> * const

        int n = 10;
        int * const pN = &n; 
        // TODO: fixme
        // если int const * -> это указатель на константу типа int 

        // работает
    }
    
    /**
     * Задание 8.1.2. Указываемое значение является константой. 
     */

    {
        const int n = 10;
        const int * pN = &n;

        //работает
    }

    /**
     * Задание 8.1.3. И указатель, и указываемое значение являются константами. 
     */

    {
        const int n = 10;
        const int * const pN = &n;

        // работает
    }

    /**
     * Задание 8.2. Указатель на переменную, объявленную с ключевым словом
     * const. 
     *
     * Объявите указатель и проинициализируйте его выражением - `&nN`.
     */

    {
        const int nN = 1;
        const int * pN;
        pN = &nN;

        // работает
    }

    /**
     * Задание 9. Указатели на указатели.
     */

    {
        int n = 1;

        /** 
         * Объявите указатель pn и проинициализируйте его так, чтобы он
         * "указывал" на n. 
         */
        int* pn = &n;

        /** 
         * Объявите указатель ppn и проинициализируйте его так, чтобы он
         * "указывал" на pn. 
         */
        int** ppn = &pn;

        /** 
         * Объявите указатель pppn и проинициализируйте его так, чтобы он
         * "указывал" на ppn. 
         */
        int*** pppn = &ppn;

        /** 
         * С помощью указателей pn, ppn и pppn получите значение объекта n и
         * присвойте его m.
         */

        int m = *(*(*pppn));
        m = *(*ppn);
        m = *pn;

        //работает
    }
    return 0;
}
