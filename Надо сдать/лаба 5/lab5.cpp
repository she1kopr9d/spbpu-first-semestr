/**
 * Практическое занятие №5. "Старые" потоковые функции стандартной библиотеки.
 * Указатели на функции. Структуры.
 */

#include <iostream>
#include <cstdio>
#include <cmath>
#include "other.h"
#include "book.h"
#include "matrix.h"

Book global_book;

int main()
{
    {
    /**
     * Задание 1. "Старые" потоковые функции стандартной библиотеки.
     *
     * Эти функции использовались в языке C. Если вы будете писать программы на
     * нем, вам придется использовать их вместо std::cin и std::cout.
     */

    /**
     * Задание 1.1.
     *
     * С помощью функции scanf сформирйуте три коэффициента: A,B,C.
     */

    // первая проверка +

        double A, B, C;

        printf("Введите коэффициенты A, B и C через пробел: ");
        
        if (scanf("%lf %lf %lf", &A, &B, &C) != 3) {
            printf("Ошибка\n");
            return 1;
        }

        printf("Введенные коэффициенты:\n");
        printf("A = %.2lf\n", A);
        printf("B = %.2lf\n", B);
        printf("C = %.2lf\n", C);

    /**
     * Задание 1.2.
     *
     * Выведите (красиво!) таблицу значений y=A*x*x + B*x + C при изменении x в
     * диапазоне -2 до +2 с шагом 0.5
     */

    // первая проверка +

        printf("|-----");
        for(float i = -2; i < 2; i+=0.5)
            printf("|-----");
        printf("|\n");
        printf("|    x");
        for(float i = -2; i < 0; i+=0.5){
            printf("|%.2lf", i);
        }
        for(float i = 0; i < 2; i+=0.5){
            printf("| %.2lf", i);
        }
        printf("|\n");
        printf("|-----");
        for(float i = -2; i < 2; i+=0.5)
            printf("|-----");
        printf("|\n");
        printf("|    y");
        float y;
        for(float i = -2; i < 2; i+=0.5){
            y = A*i*i + B*i + C;
            if (y >= 0)
                printf("| %.2lf", y);
            else
                printf("|%.2lf", y);
        }
        printf("|\n");
        printf("|-----");
        for(float i = -2; i < 2; i+=0.5)
            printf("|-----");
        printf("|\n");
    }
    /**
     * Задание 2. Указатели на функции.
     */

    /**
     * Задание 2.1. Указатель на функцию. "Калькулятор".
     *
     * Напишите функции:
     * 1. add - принимает два значения double и возвращает сумму этих значений;
     * 2. sub- принимает два значения double и возвращает разность этих
     *    значений;
     * 3. mul - аналогично для умножения;
     * 4. div - аналогично для деления;
     * 5. а для возведения в степень можете использовать функцию стандартной
     *    библиотеки - pow(). 
     *
     * Подсказка 1: прототип функции находится в <cmath>.
     * Подсказка 2: стандартная библиотека предоставляет несколько
     * перегруженных вариантов этой функции, а Вам потребуется сформировать
     * указатель на double pow(double, double).
     *
     * Предоставьте пользователю следующую возможность:
     *
     * - пока пользователь хочет пользоваться услугами вашего калькулятора, он
     *   может вводить два значения и знак операции а вы выводите результат. 
     * - результат получаете посредством вызова соответствующей вашей функции
     *   по указателю.
     * - предусмотрите возможность ввода непредусмотренного знака операции.
     */

    // первая проверка +

    {
        double (*operation)(double, double) = NULL; // Указатель на функцию
        char operato; // Оператор (+, -, *, /, ^)
        double a, b;   // Операнды

        printf("Простой калькулятор. Введите выражение в формате: a оператор b\n");
        printf("Операторы: + (сложение), - (вычитание), * (умножение), / (деление), ^ (степень)\n");
        printf("Для выхода введите q.\n");

        while (1) {
            printf("\nВведите выражение: ");
            
            // Считываем входные данные
            if (scanf(" %lf %c %lf", &a, &operato, &b) != 3) {
                char exitChar;
                scanf(" %c", &exitChar);
                if (exitChar == 'q') {
                    printf("Выход из программы.\n");
                    break;
                } else {
                    printf("Ошибка ввода. Попробуйте снова.\n");
                    continue;
                }
            }

            // Выбор функции по оператору
            switch (operato) {
                case '+':
                    operation = add;
                    break;
                case '-':
                    operation = sub;
                    break;
                case '*':
                    operation = mul;
                    break;
                case '/':
                    operation = div;
                    break;
                case '^':
                    operation = pow; // Используем стандартную библиотечную функцию
                    break;
                default:
                    printf("Ошибка: неизвестная операция '%c'.\n", operato);
                    continue;
            }

            // Вычисление результата
            if (operation) {
                double result = operation(a, b);
                printf("Результат: %.2lf\n", result);
            }
        }
    }
    /**
     * Задание 2.2. Указатель на функцию в качестве аргумента.
     *
     * Дана заготовка функции сортировки любых объектов - sort.
     *
     * Функция принимает следующие параметры:
     * 1. указатель на первый сортируемый элемент
     * 2. количество сортируемых элементов
     * 3. размер элемента в байтах
     * 4. указатель на функцию перестановки элементов
     * 5. указатель на функцию сравнения элементов
     */

    /**
     * Задание 2.2.1.
     *
     * Напишите функцию перестановки двух целых значений - swap_int, которая
     * принимает два void указателя и меняет значения местами.
     *
     * Напишите функцию сравнения двух целых значений - CmpInt, которая
     * принимает два void указателя и возвращает int результат сравнения:  
     * <0 - первый элемент меньше, чем второй;
     * =0 - равны;
     * >0 - первый элемент больше, чем второй.
     *
     * Используйте эти функции в функции сортировки.
     */

    // первая проверка +

    {
        int nAr[] = {5, 2, 8, 1, 4};   //массив для сортировки
        int nTotal = sizeof(nAr) / sizeof(nAr[0]);          //количество элементов в массиве 

        /** Печать исходного массива */
        printf("Исходный массив:\n");
        for (int i = 0; i < nTotal; i++) {
            printf("%d ", nAr[i]);
        }
        printf("\n");

        sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), swap_int, cmp_int);

        /** Печать результатов сортировки */
        printf("Отсортированный массив:\n");
        for (int i = 0; i < nTotal; i++) {
            printf("%d ", nAr[i]);
        }
        printf("\n");
    }

    /**
     * Задание 2.2.2.
     *
     * По аналогии с заданием 2.2.1 напишите функцию swap_double и cmp_double,
     * и вызовите функцию sort для сортировки вещественных значений.
     */

    // первая проверка +

    {
        double nAr[] = {5.12, 2.23, 8.123123, 8.4141241, 4.4314};   //массив для сортировки
        int nTotal = sizeof(nAr) / sizeof(nAr[0]);          //количество элементов в массиве 

        /** Печать исходного массива */
        printf("Исходный массив:\n");
        for (int i = 0; i < nTotal; i++) {
            printf("%f ", nAr[i]);
        }
        printf("\n");

        sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(double), swap_double, cmp_double);

        /** Печать результатов сортировки */
        printf("Отсортированный массив:\n");
        for (int i = 0; i < nTotal; i++) {
            printf("%f ", nAr[i]);
        }
        printf("\n");
    }
    /**
     * Задание 2.2.3.
     *
     * По аналогии с 2.2.1 создайте вспомогательные функции - swap_str и
     * cmp_str и вызовите функцию sort для сортировки массива указателей на
     * строки.
     */

    // первая проверка +

    {
        const char* arStr[] = {"QQQ", "SDF", "ABC"};
        int nTotal = sizeof(arStr) / sizeof(arStr[0]);
        printf("%i\n", nTotal);

        printf("Исходный массив:\n");
        int j;
        for (int i = 0; i < nTotal; i++) {
            j = 0;
            while (arStr[i][j] != '\0'){
                printf("%c", arStr[i][j++]);
            }
            printf(" ");
        }
        printf("\n");

        sort(reinterpret_cast<char*>(&arStr[0]), nTotal, sizeof(char*), swap_str, cmp_str);

        printf("Отсортированный массив:\n");
        for (int i = 0; i < nTotal; i++) {
            j = 0;
            while (arStr[i][j] != '\0'){
                printf("%c", arStr[i][j++]);
            }
            printf(" ");
        }
        printf("\n");
    }

    /**
     * Задание 2.3. Массивы указателей на функцию.
     *
     * Напишите функции для работы с массивом:
     *
     * 1. print_max - печатает максимальный элемент;
     * 2. print_min - печатает минимальный элемент;
     * 3. sort_asc - сортирует по возрастанию и выводит на печать;
     * 4. sort_desc - сортирует по убыванию и выводит на печать.
     *
     * У всех эти функций должна быть одинаковая сигнатура. Объявите, два
     * массива: массив указателей на функции 1-4 и массив указателей на строки
     * с описанием этих функций.
     *
     * Реализуйте меню для пользователя: выведите нумерованный список имен
     * функций (из второго массива), примите от пользователя номер функции,
     * после чего вызовите функцию для какого-нибудь массива.
     */

    // первая проверка +

    {
        int arr[6] = {4, 1, 7, 3, 8, 5};
        int size = 6; // Количество элементов в массиве

        // Массив указателей на функции
        void (*functions[])(int[], int) = {sort_asc, sort_desc};
        void (*read_functions[])(int[], int) = {print_max, print_min};

        // Массив описаний функций
        const char* descriptions[] = {
            "1. Печать максимального элемента",
            "2. Печать минимального элемента",
            "3. Сортировка по возрастанию",
            "4. Сортировка по убыванию"};

        while (1) {
            // Вывод меню
            printf("\nМеню:\n");
            for (int i = 0; i < 4; ++i) {
                printf("%s\n", descriptions[i]);
            }
            printf("5. Выход\n");
            printf("Выберите номер функции: ");

            int choice;
            scanf("%d", &choice);

            // Проверка ввода
            if (choice == 5) {
                printf("Выход из программы.\n");
                break;
            }

            if (choice >= 1 && choice <= 2) {
                (*(read_functions[choice - 1]))(arr, size);
            } else if (choice >= 3 && choice <= 4) {
                (*(functions[choice - 3]))(arr, size);
            } else {
                printf("Неверный выбор. Попробуйте снова.\n");
            }
        }

    }

    /**
     * Задание 2.4. Метод прямоугольников.
     *
     * Напишите функцию integrate, которая бы принимала:
     * 1. указатель на интегрируемую функцию, которая принимает double и
     *    возвращает double;
     * 2. нижнюю границу интегрирования (вещественное число);
     * 3. верхнюю границу интегрирования (вещественное число);
     * 4. количество отрезков, на которых будет вычисляться функция.
     *
     * Функция должна возвращать численное значение определенного интеграла,
     * полученного методом прямоугольников.
     *
     * Проверьте функцию на разных вещественных функциях (линейных, параболах,
     * exp, sin) и сравните полученные результаты с теоретическими.
     */

    // первая проверка +

    {
        double result_linear = integrate(linear_func, 0.0, 1.0, 1000);
        printf("Интеграл от линейной функции [0, 1]: %.6f\n", result_linear);

        double result_parabola = integrate(parabola_func, 0.0, 1.0, 1000);
        printf("Интеграл от функции x^2 [0, 1]: %.6f\n", result_parabola);

        double result_exp = integrate(exp_func, 0.0, 1.0, 1000);
        printf("Интеграл от функции e^x [0, 1]: %.6f\n", result_exp);

        double result_sin = integrate(sin_func, 0.0, 3.14159265359, 1000);
        printf("Интеграл от функции sin(x) [0, π]: %.6f\n", result_sin);
    }

    /**
     * Задание 3. Структуры С.
     */

    /**
     * Задание 3.1. Структура Book.
     */
    {
    /**
     * Задание 3.1.1.
     *
     * Объявите структуру Book, описывающую книгу (автор, заглавие, год
     * издания, цена, категория…).
     *
     * Подумайте: какого типа могут быть поля структуры.
     * Подсказка: объявление структуры рекомендуется выносить в заголовочный
     * файл.
     */

    // сделал в файле book.h

    /**
     * Задание 3.1.2.
     *
     * Создайте разными способами (глобальный, локальный, статический,
     * динамический) экземпляры (объекты) типа Book (без инициализации).
     *
     * Определите - сколько памяти отводит компилятор под каждый такой объект. 
     *
     * Как инициализируются (или не инициализируются) поля структуры?
     *
     * Подумайте: от чего зависит объем выделяемой памяти?
     */

    // global_book - обьявлен в начале файла

    // первая проверка +

    Book local_book;

    static Book static_book;

    Book * dinamic_book;

    dinamic_book = new Book();

    /**
     * Задание 3.1.3. 
     *
     * Заполните поля созданных объектов.
     *
     * Замечание: если для хранения строки используется массив, необходимо
     * предусмотреть "защиту" от выхода за границы массива.
     */

    // первая проверка +

    init_book(global_book, "Author 1", "Title 1", 1923, 23.50, "Fantasy 1");
    init_book(local_book, "Author 2", "Title 2", 1924, 24.50, "Fantasy 2");
    init_book(static_book, "Author 3", "Title 3", 1925, 25.50, "Fantasy 3");
    init_book(*dinamic_book, "Author 4", "Title 4", 1926, 26.50, "Fantasy 4");

    /**
     * Задание 3.1.4. 
     *
     * Напишите функцию, выводящую на экран реквизиты книги.
     *
     * Подумайте: как эффективнее передавать экземпляр Book в функцию.
     *
     * Для вывода на консоль используйте функцию стандартной библиотеки printf.
     */

    // первая проверка +

    print_book(global_book);
    print_book(local_book);
    print_book(static_book);
    print_book(*dinamic_book);

    /**
     * Задание 3.1.5.
     *
     * Напишите функцию для формирования полей структуры. Для ввода используйте
     * функцию стандартной библиотеки scanf.
     *
     * Замечание: неплохо заложить в такую функцию возможность проверки
     * корректности введенного значения, например, год издания не может быть
     * меьше, чем... (год появления письменности), категорию ползователь должен
     * выбирать из существующих, цена не может быть отрицательной...
     *
     * Кроме этого необходимо проверить и ошибки другого рода: программа
     * ожидает число, а пользователь ввел случайно букву.
     */

    // первая проверка +

    input_book(*dinamic_book);
    print_book(*dinamic_book);

    delete[] (*dinamic_book).author;
    delete[] (*dinamic_book).title;
    delete[] (*dinamic_book).category;
    delete dinamic_book;

    }
    /**
     * Задание 3.2. Матричные операции.
     */

    /**
     * Задание 3.2.1. 
     *
     * Задайте структуру Matrix, которая будет преставлять вещественную матрицу
     * размера MxN из линейной алгебры.
     *
     * Это определение и связанные с ними функции определите в отдельной паре
     * файлов: matrix.h и matrix.cpp.
     */

    //сделал

    /**
     * Задание 3.2.2.
     *
     * Создайте набор базовых функций для работы с этой структурой:
     *
     * - void m_zero(Matrix *A, int m, int n) - инициализация матрицы размера m
     *   на n нулями;
     * - void m_id(Matrix *A, int n) - инициализация единичной матрицы n на n;
     * - void m_free(Matrix *A) - очистка памяти, используемой для матрицы;
     * - void m_copy(const Matrix *src, Matrix *dst) - копирование данных
     *   матрицы src в матрицу dst.
     * - int m_width(const Matrix *A) - ширина матрицы A;
     * - int m_height(const Matrix *A) - высота матрицы A;
     * - double m_get(const Matrix* A, int i, int j) - получение i,j-того
     *   элемента матрицы;
     * - void m_set(Matrix *A, int i, int j, double value) - установка i,j-того
     *   элемента матрицы.
     */

    //сделал

    /**
     * Задание 3.2.3.
     *
     * Реализуйте набор операций из линейной алгебры:
     *
     * - int m_add(Matrix *A, const Matrix *B) - если A и B одинакового
     *   размера, то прибавляет к A значения B и возвращает 0; иначе возвращает
     *   1.
     * - void m_neg(Matrix *A) - заменяет все элементы матрицы A на
     *   противоположные.
     * - int m_mult(const Matrix *A, const Matrix *B, Matrix *dst) - умножает
     *   матрицу A на матрицу B и сохраняет результат в dst. Если размеры
     *   матрицы не позволяют умножить матрицы, функция возвращает 1, иначе 0.
     */

    //cделал

    /**
     * Задание 3.2.4.
     *
     * С помощью полученного функционала реализуйте матричное вычисление чисел
     * Фибоначчи. Делается это с помощью такой формулы:
     *
     * /  F[n]  \ = / 1  1 \ * / F[n-1] \
     * \ F[n-1] /   \ 1  0 /   \ F[n-2] /
     *
     * Задайте матрицу в центре и матрицу-вектор с двумя первыми числами
     * Фибоначчи: 1 и 0. Выполняйте эту формулу итеративно и выведите первые 40
     * чисел Фибоначчи.
     */

    // первая проверка +

    {
        
        Matrix * A = new Matrix{0, 0, 0};
        Matrix * B = new Matrix();
        Matrix * C = new Matrix();

        m_zero(A, 2, 2);
        m_zero(B, 2, 1);

        m_set(A, 0, 0, 1.);
        m_set(A, 1, 0, 1.);
        m_set(A, 0, 1, 1.);

        m_set(B, 0, 0, 1.);
        m_set(B, 1, 0, 1.);

        int choice;
        int i = 1;
        while (1) {
            printf("\nЧисло фибоначи под номером %d: %lf\n\n", i, m_get(B, 1, 0));
            printf("\nМеню:\n");
            printf("1. Перемножить матрицы\n");
            printf("2. Выход\n");
            printf("Выберите номер функции: ");

            scanf("%d", &choice);

            if (choice == 2) {
                printf("Выход из программы.\n");
                break;
            }

            m_mult(A, B, C);
            m_copy(C, B);
        }

        m_free(A);
        m_free(B);
        m_free(C);

        delete A;
        delete B;
        delete C;
    }

    return 0;
}
